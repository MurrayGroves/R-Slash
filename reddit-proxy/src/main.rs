mod reddit_proxy;

use std::{env, future};

use crate::reddit_proxy::RedditProxyError::{RequestError, TextDecodeError, TokenError};
use crate::reddit_proxy::{RedditProxy, RedditProxyError};
use opentelemetry::global;
use opentelemetry_otlp::WithExportConfig;
use opentelemetry_sdk::{logs, trace};
use reqwest::RequestBuilder;
use rslash_common::access_tokens::get_reddit_access_token;
use rslash_common::{Limiter, SubredditStatus, initialise_observability, span_filter};
use tarpc::context::Context;
use tarpc::server;
use tarpc::server::Channel;
use tarpc::tokio_serde::formats::Bincode;

use futures::StreamExt;
use tokio::spawn;

use tracing::log::debug;
use tracing::{error, info, warn};
use tracing_subscriber::{
    EnvFilter, Layer, prelude::__tracing_subscriber_SubscriberExt, util::SubscriberInitExt,
};

#[derive(Clone)]
struct RedditProxyServer {
    limiter: Limiter,
    reddit_secret: String,
    reddit_client_id: String,
    web_client: reqwest::Client,
    redis: redis::aio::MultiplexedConnection,
}

impl RedditProxyServer {
    async fn attach_auth_token(
        &self,
        request: RequestBuilder,
    ) -> Result<RequestBuilder, RedditProxyError> {
        match get_reddit_access_token(
            &mut self.redis.clone(),
            &self.reddit_client_id,
            &self.reddit_secret,
            Some(&self.web_client),
            None,
        )
        .await
        {
            Ok(token) => Ok(request.bearer_auth(token)),
            Err(e) => Err(TokenError(e.to_string())),
        }
    }
}

impl RedditProxy for RedditProxyServer {
    async fn get(self, _: Context, url: String) -> Result<String, RedditProxyError> {
        self.limiter.wait().await;
        let resp = match self
            .attach_auth_token(self.web_client.get(url))
            .await?
            .send()
            .await
        {
            Ok(resp) => resp,
            Err(e) => {
                return Err(RequestError(e.to_string()));
            }
        };

        match resp.text().await {
            Ok(text) => Ok(text),
            Err(e) => Err(TextDecodeError(e.to_string())),
        }
    }

    async fn check_subreddit_valid(
        self,
        _: Context,
        subreddit: String,
    ) -> Result<SubredditStatus, RedditProxyError> {
        let res = match self
            .attach_auth_token(
                self.web_client
                    .head(format!("https://oauth.reddit.com/r/{}.json", subreddit)),
            )
            .await?
            .send()
            .await
        {
            Ok(x) => x,
            Err(e) => return Err(RequestError(e.to_string())),
        };

        debug!("Subreddit check response: {:?}", res);
        Ok(if res.status() == 200 {
            SubredditStatus::Valid
        } else {
            SubredditStatus::Invalid(match res.text().await {
                Ok(x) => x,
                Err(e) => return Err(TextDecodeError(e.to_string())),
            })
        })
    }
}

#[tokio::main]
async fn main() {
    initialise_observability!("reddit-proxy");

    let reddit_secret = env::var("REDDIT_SECRET").expect("REDDIT_SECRET not present");
    let reddit_client_id = env::var("REDDIT_CLIENT").expect("REDDIT_CLIENT not present");

    if let Ok(res) = reqwest::get("https://api.ipify.org").await
        && let Ok(txt) = res.text().await
    {
        println!("External IP is {}", txt);
    } else {
        println!("Could not get external IP");
    }

    let redis_client =
        redis::Client::open("redis://redis.discord-bot-shared.svc.cluster.local/").unwrap();
    let con = redis_client
        .get_multiplexed_async_connection()
        .await
        .expect("Can't connect to redis");

    println!("Connected to Redis");

    let server = RedditProxyServer {
        limiter: Limiter::new(None, "reddit".to_string()),
        reddit_secret,
        reddit_client_id,
        redis: con,
        web_client: reqwest::Client::builder()
            .redirect(reqwest::redirect::Policy::none())
            .user_agent(format!(
                "Discord:RSlash:{} (by /u/murrax2)",
                env!("CARGO_PKG_VERSION")
            ))
            .build()
            .unwrap(),
    };

    let mut listener = tarpc::serde_transport::tcp::listen("0.0.0.0:50051", Bincode::default)
        .await
        .unwrap();
    listener.config_mut().max_frame_length(usize::MAX);
    listener
        // Ignore accept errors.
        .filter_map(|r| future::ready(r.ok()))
        .map(server::BaseChannel::with_defaults)
        // serve is generated by the service attribute. It takes as input any type implementing
        // the generated SubscriberServer trait.
        .map(move |channel| {
            let server = server.clone();
            channel
                .execute(server.serve())
                .for_each(|response| async move {
                    println!("Incoming connection");
                    spawn(response);
                })
        })
        // Max 10 channels.
        .buffer_unordered(99999999)
        .for_each(|_| async {})
        .await;

    println!("Exited");
}
